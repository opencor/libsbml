using System;
using System.Runtime.InteropServices;
 
//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.12
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace libsbmlcs {

 using System;
 using System.Runtime.InteropServices;

/** 
 * @sbmlpackage{core}
 *
@htmlinclude pkg-marker-core.html Set of SBML Level + Version + namespace triples.
 *
 * @htmlinclude not-sbml-warning.html
 *
 * SBMLExtensionNamespaces is a template class.  It is extended from
 * SBMLNamespaces and is meant to be used by package extensions to store the
 * SBML Level, Version within a Level, and package version of the SBML
 * Level&nbsp;3 package implemented by a libSBML package extension.
 *
 * @if clike
 * @section sbmlextensionnamespaces-howto How to use SBMLExtensionNamespaces for a package implementation
 *
 * 
 * Each package extension in libSBML needs to extend and instantiate the
 * template class SBMLExtensionNamespaces, as well as declare a specific
 * <code>typedef</code>.  The following sections explain these steps in detail.
 *
 *
 * @subsection sen-identify 1. Define the typedef
 *
 * Each package needs to declare a package-specific version of the
 * SBMLExtensionNamespaces class using a <code>typedef</code>.  The following
 * example code demonstrates how this is done in the case of the Layout package:
 *
 * @code{.cpp}
 * typedef SBMLExtensionNamespaces<LayoutExtension> LayoutPkgNamespaces;
 * @endcode
 *
 * This creates a new type called LayoutPkgNamespaces.  The code above is
 * usually placed in the same file that contains the SBMLExtension-derived
 * definition of the package extension base class.  In the case of the Layout
 * package, this is in the file
 * <code>src/packages/layout/extension/LayoutExtension.h</code> in the libSBML
 * source distribution.
 *
 *
 * @subsection sen-instantiate 2. Instantiate a template instance
 *
 * Each package needs to instantiate a template instance of the
 * SBMLExtensionNamespaces class.  The following
 * example code demonstrates how this is done in the case of the Layout package:
 *
 * @code{.cpp}
 * template class LIBSBML_EXTERN SBMLExtensionNamespaces<LayoutExtension>;
 * @endcode
 *
 * In the case of the Layout package, the code above is located in the file
 * <code>src/packages/layout/extension/LayoutExtension.cpp</code> in the libSBML
 * source distribution.
 *
 *
 * @subsection sen-derive 3. Create constructors that accept the class
 *
 * Each SBase-derived class in the package extension should implement a
 * constructor that accepts the SBMLExtensionNamespaces-derived class as an
 * argument.  For example, in the Layout package, the class BoundBox has a
 * constructor declared as follows
 *
 * @code{.cpp}
 * BoundingBox(LayoutPkgNamespaces* layoutns);
 * @endcode
 *
 * The implementation of this constructor must, among other things, take the
 * argument namespace object and use it to set the XML namespace URI for the
 * object.  Again, for the BoundingBox example:
 *
 * @code{.cpp}
 * BoundingBox::BoundingBox(LayoutPkgNamespaces* layoutns)
 *  : SBase(layoutns)
 *   ,mPosition(layoutns)
 *   ,mDimensions(layoutns)
 *   ,mPositionExplicitlySet (false)
 *   ,mDimensionsExplicitlySet (false)
 * {
 *   // Standard extension actions.
 *   setElementNamespace(layoutns->getURI());
 *   connectToChild();
 *
 *   // Package-specific actions.
 *   mPosition.setElementName('position');
 *
 *   // Load package extensions bound with this object (if any).
 *   loadPlugins(layoutns);
 * }
 * @endcode
 *
 *
 * @else
 *
 * @section ext-basics Basic principles of SBML package extensions in libSBML
 *
 * 
 * SBML Level&nbsp;3's package structure permits modular extensions to the
 * core SBML format.  In libSBML, support for SBML Level&nbsp;3 packages is
 * provided through optional <em>package extensions</em> that can be plugged
 * into libSBML at the time it is built/compiled.  Users of libSBML can thus
 * choose which extensions are enabled in their software applications.
 *
 * LibSBML defines a number of classes that developers of package extensions
 * can use to implement support for an SBML Level&nbsp;3 package.  These
 * classes make it easier to extend libSBML objects with new attributes
 * and/or subobjects as needed by a particular Level&nbsp;3 package.
 * Three overall categories of classes make up libSBML's facilities for
 * implementing package extensions.  There are (1) classes that serve as base
 * classes meant to be subclassed, (2) template classes meant to be
 * instantiated rather than subclassed, and (3) support classes that provide
 * utility features. A given package implementation for libSBML will take
 * the form of code using these and other libSBML classes, placed in a
 * subdirectory of <code>src/sbml/packages/</code>.
 *
 * The basic libSBML distribution includes a number of package extensions
 * implementing support for officially-endorsed SBML Level&nbsp;3 packages;
 * among these are <em>Flux Balance Constraints</em> ('fbc'),
 * <em>Hierarchical %Model Composition</em> ('comp'), <em>%Layout</em>
 * ('layout'), and <em>Qualitative Models</em> ('qual').  They can serve as
 * working examples for developers working to implement other packages.
 *
 * Extensions in libSBML can currently only be implemented in C++ or C;
 * there is no mechanism to implement them first in languages such as
 * Java or Python.  However, once implemented in C++ or C, language
 * interfaces can be generated semi-automatically using the framework in
 * place in libSBML.  (The approach is based on using <a target='_blank'
 * href='http://www.swig.org'>SWIG</a> and facilities in libSBML's build
 * system.)
 *
 *
 * @endif
 */

public class L3v2extendedmathPkgNamespaces : SBMLNamespaces {
	private HandleRef swigCPtr;
	
	internal L3v2extendedmathPkgNamespaces(IntPtr cPtr, bool cMemoryOwn) : base(libsbmlPINVOKE.L3v2extendedmathPkgNamespaces_SWIGUpcast(cPtr), cMemoryOwn)
	{
		//super(libsbmlPINVOKE.L3v2extendedmathPkgNamespacesUpcast(cPtr), cMemoryOwn);
		swigCPtr = new HandleRef(this, cPtr);
	}
	
	internal static HandleRef getCPtr(L3v2extendedmathPkgNamespaces obj)
	{
		return (obj == null) ? new HandleRef(null, IntPtr.Zero) : obj.swigCPtr;
	}
	
	internal static HandleRef getCPtrAndDisown (L3v2extendedmathPkgNamespaces obj)
	{
		HandleRef ptr = new HandleRef(null, IntPtr.Zero);
		
		if (obj != null)
		{
			ptr             = obj.swigCPtr;
			obj.swigCMemOwn = false;
		}
		
		return ptr;
	}

  ~L3v2extendedmathPkgNamespaces() {
    Dispose();
  }

  public override void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          libsbmlPINVOKE.delete_L3v2extendedmathPkgNamespaces(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
      base.Dispose();
    }
  }

  public L3v2extendedmathPkgNamespaces(long level, long version, long pkgVersion, string prefix) : this(libsbmlPINVOKE.new_L3v2extendedmathPkgNamespaces__SWIG_0(level, version, pkgVersion, prefix), true) {
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
  }

  public L3v2extendedmathPkgNamespaces(long level, long version, long pkgVersion) : this(libsbmlPINVOKE.new_L3v2extendedmathPkgNamespaces__SWIG_1(level, version, pkgVersion), true) {
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
  }

  public L3v2extendedmathPkgNamespaces(long level, long version) : this(libsbmlPINVOKE.new_L3v2extendedmathPkgNamespaces__SWIG_2(level, version), true) {
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
  }

  public L3v2extendedmathPkgNamespaces(long level) : this(libsbmlPINVOKE.new_L3v2extendedmathPkgNamespaces__SWIG_3(level), true) {
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
  }

  public L3v2extendedmathPkgNamespaces() : this(libsbmlPINVOKE.new_L3v2extendedmathPkgNamespaces__SWIG_4(), true) {
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
  }

  public L3v2extendedmathPkgNamespaces(L3v2extendedmathPkgNamespaces orig) : this(libsbmlPINVOKE.new_L3v2extendedmathPkgNamespaces__SWIG_5(L3v2extendedmathPkgNamespaces.getCPtr(orig)), true) {
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
  }

  
/**
   * Creates and returns a deep copy of this SBMLNamespaces object.
   *
   * @return the (deep) copy of this SBMLNamespaces object.
   */ public new
 SBMLNamespaces clone() {
    global::System.IntPtr cPtr = libsbmlPINVOKE.L3v2extendedmathPkgNamespaces_clone(swigCPtr);
    ISBMLExtensionNamespaces ret = (cPtr == global::System.IntPtr.Zero) ? null : new ISBMLExtensionNamespaces(cPtr, true);
    return ret;
  }

  
/**
   * Returns a string representing the SBML XML namespace of this
   * object.
   *
   * @return a string representing the SBML namespace that reflects the
   * SBML Level and Version of this object.
   */ public new
 string getURI() {
    string ret = libsbmlPINVOKE.L3v2extendedmathPkgNamespaces_getURI(swigCPtr);
    return ret;
  }

  public long getPackageVersion() { return (long)libsbmlPINVOKE.L3v2extendedmathPkgNamespaces_getPackageVersion(swigCPtr); }

  
/**
   * Returns the name of the main package for this namespace.
   *
   * @return the name of the main package for this namespace.
   * 'core' will be returned if this namespace is defined in the SBML 
   * core. 
   */ public new
 string getPackageName() {
    string ret = libsbmlPINVOKE.L3v2extendedmathPkgNamespaces_getPackageName(swigCPtr);
    return ret;
  }

}

}
