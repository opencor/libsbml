//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.12
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace libsbml {

 using System;
 using System.Runtime.InteropServices;

/** 
 * @sbmlpackage{l3v2extendedmath}
 *
@htmlinclude pkg-marker-l3v2extendedmath.html Extension of AST.
 */

public class L3v2extendedmathASTPlugin : ASTBasePlugin {
	private HandleRef swigCPtr;
	
	internal L3v2extendedmathASTPlugin(IntPtr cPtr, bool cMemoryOwn) : base(libsbmlPINVOKE.L3v2extendedmathASTPlugin_SWIGUpcast(cPtr), cMemoryOwn)
	{
		//super(libsbmlPINVOKE.L3v2extendedmathASTPluginUpcast(cPtr), cMemoryOwn);
		swigCPtr = new HandleRef(this, cPtr);
	}
	
	internal static HandleRef getCPtr(L3v2extendedmathASTPlugin obj)
	{
		return (obj == null) ? new HandleRef(null, IntPtr.Zero) : obj.swigCPtr;
	}
	
	internal static HandleRef getCPtrAndDisown (L3v2extendedmathASTPlugin obj)
	{
		HandleRef ptr = new HandleRef(null, IntPtr.Zero);
		
		if (obj != null)
		{
			ptr             = obj.swigCPtr;
			obj.swigCMemOwn = false;
		}
		
		return ptr;
	}

  ~L3v2extendedmathASTPlugin() {
    Dispose();
  }

  public override void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          libsbmlPINVOKE.delete_L3v2extendedmathASTPlugin(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
      base.Dispose();
    }
  }

  
/**
   * Creates a new L3v2extendedmathASTPlugin object.
   *
   */ public
 L3v2extendedmathASTPlugin() : this(libsbmlPINVOKE.new_L3v2extendedmathASTPlugin__SWIG_0(), true) {
  }

  
/** */ public
 L3v2extendedmathASTPlugin(L3v2extendedmathASTPlugin orig) : this(libsbmlPINVOKE.new_L3v2extendedmathASTPlugin__SWIG_1(L3v2extendedmathASTPlugin.getCPtr(orig)), true) {
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
  }

  
/**
  * Creates and returns a deep copy of this L3v2extendedmathASTPlugin object.
  *
  * @return the (deep) copy of this L3v2extendedmathASTPlugin object.
  */ public new
 ASTBasePlugin clone() {
    global::System.IntPtr cPtr = libsbmlPINVOKE.L3v2extendedmathASTPlugin_clone(swigCPtr);
    L3v2extendedmathASTPlugin ret = (cPtr == global::System.IntPtr.Zero) ? null : new L3v2extendedmathASTPlugin(cPtr, true);
    return ret;
  }

  
/** */ public new
 bool hasCorrectNamespace(SBMLNamespaces namespaces) {
    bool ret = libsbmlPINVOKE.L3v2extendedmathASTPlugin_hasCorrectNamespace(swigCPtr, SBMLNamespaces.getCPtr(namespaces));
    return ret;
  }

  
/** */ public
 L3v2extendedmathASTPlugin(string uri) : this(libsbmlPINVOKE.new_L3v2extendedmathASTPlugin__SWIG_2(uri), true) {
  }

  
/** */ public new
 int checkNumArguments(ASTNode function, SWIGTYPE_p_std__stringstream error) {
    int ret = libsbmlPINVOKE.L3v2extendedmathASTPlugin_checkNumArguments(swigCPtr, ASTNode.getCPtr(function), SWIGTYPE_p_std__stringstream.getCPtr(error));
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/** */ public new
 double evaluateASTNode(ASTNode node, Model m) {
    double ret = libsbmlPINVOKE.L3v2extendedmathASTPlugin_evaluateASTNode__SWIG_0(swigCPtr, ASTNode.getCPtr(node), Model.getCPtr(m));
    return ret;
  }

  
/** */ public new
 double evaluateASTNode(ASTNode node) {
    double ret = libsbmlPINVOKE.L3v2extendedmathASTPlugin_evaluateASTNode__SWIG_1(swigCPtr, ASTNode.getCPtr(node));
    return ret;
  }

  
/** 
   * returns the unitDefinition for the ASTNode from a rem function
   */ public
 UnitDefinition getUnitDefinitionFromRem(SWIGTYPE_p_UnitFormulaFormatter uff, ASTNode node, bool inKL, int reactNo) {
    global::System.IntPtr cPtr = libsbmlPINVOKE.L3v2extendedmathASTPlugin_getUnitDefinitionFromRem(swigCPtr, SWIGTYPE_p_UnitFormulaFormatter.getCPtr(uff), ASTNode.getCPtr(node), inKL, reactNo);
    UnitDefinition ret = (cPtr == global::System.IntPtr.Zero) ? null : new UnitDefinition(cPtr, false);
    return ret;
  }

  
/** 
   * returns the unitDefinition for the ASTNode from a rateOf function
   */ public
 UnitDefinition getUnitDefinitionFromRateOf(SWIGTYPE_p_UnitFormulaFormatter uff, ASTNode node, bool inKL, int reactNo) {
    global::System.IntPtr cPtr = libsbmlPINVOKE.L3v2extendedmathASTPlugin_getUnitDefinitionFromRateOf(swigCPtr, SWIGTYPE_p_UnitFormulaFormatter.getCPtr(uff), ASTNode.getCPtr(node), inKL, reactNo);
    UnitDefinition ret = (cPtr == global::System.IntPtr.Zero) ? null : new UnitDefinition(cPtr, false);
    return ret;
  }

  
/** */ public new
 UnitDefinition getUnitDefinitionFromPackage(SWIGTYPE_p_UnitFormulaFormatter uff, ASTNode node, bool inKL, int reactNo) {
    global::System.IntPtr cPtr = libsbmlPINVOKE.L3v2extendedmathASTPlugin_getUnitDefinitionFromPackage(swigCPtr, SWIGTYPE_p_UnitFormulaFormatter.getCPtr(uff), ASTNode.getCPtr(node), inKL, reactNo);
    UnitDefinition ret = (cPtr == global::System.IntPtr.Zero) ? null : new UnitDefinition(cPtr, false);
    return ret;
  }

  
/** */ public new
 bool isLogical(int type) {
    bool ret = libsbmlPINVOKE.L3v2extendedmathASTPlugin_isLogical(swigCPtr, type);
    return ret;
  }

  
/**
   * Check if the node type is known to be allowed inside function definitions.
   *
   * Function definitions must be able to be evaluated without resort to outside information.
   * Therefore, some ASTNodes (like AST_TIME and AST_FUNCTION_RATE_OF) are disallowed
   * from appearing there.  This function checks whether this is true for a given type:
   * a return value of '-1' means the plugin has no knowledge of that type; a return
   * value of '1' means the plugin knows that the type is indeed allowed, and a
   * return value of '0' means that the plugin knows that the type is not allowed.
   */ public new
 int allowedInFunctionDefinition(int type) {
    int ret = libsbmlPINVOKE.L3v2extendedmathASTPlugin_allowedInFunctionDefinition(swigCPtr, type);
    return ret;
  }

}

}
